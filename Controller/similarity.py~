import numpy as np
from read_blosum62 import find_sim_score

def smith_waterman(a, b, alignment_score = 1.0, gap_cost = 1.0):
    """
    Compute the Smith-Waterman alignment score for two strings.
    See https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm#Algorithm
    This implementation has a fixed gap cost (i.e. extending a gap is considered
    free). In the terminology of the Wikipedia description, W_k = {c, c, c, ...}.
    This implementation also has a fixed alignment score, awarded if the relevant
    characters are equal.
    Kinda slow, especially for large (50+ char) inputs.
    """
    # H holds the alignment score at each point, computed incrementally
    H = np.zeros((len(a) + 1, len(b) + 1))
    # For two 15 letter sequences:
    # ((0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0))
    for i in range(1, len(a) + 1):
        for j in range(1, len(b) + 1):
            # The score for substituting the letter a[i-1] for b[j-1]. Generally low
            # for mismatch, high for match.
            alignment_score = find_sim_score(a[i-1], b[j-1])
            match = H[i-1,j-1] + alignment_score
            # The scores for for introducing extra letters in one of the strings (or
            # by symmetry, deleting them from the other).
            delete = H[1:i,j].max() - gap_cost if i > 1 else 0
            insert = H[i,1:j].max() - gap_cost if j > 1 else 0
            H[i,j] = max(match, delete, insert, 0)
    # The highest score is the best local alignment.
    # For our purposes, we don't actually care _what_ the alignment was, just how
    # aligned the two strings were.
    return H.max()

def get_score_markers(peptide1, peptide2):
    score_markers = ''

    if len(peptide1) != len(peptide2):
        print "Peptides different lengths: Error"

    else:
        for i, cha in enumerate(peptide1):
            alignment_score = find_sim_score(cha, peptide2[i])
            if alignment_score >= 3:
                score_markers = score_markers + '|'
            elif alignment_score > 0 and alignment_score < 3:
                score_markers = score_markers + ':'
            elif alignment_score < -3:
                score_markers = score_markers + 'x'
            else:
                score_markers = score_markers + ' '

    return score_markers

def get_scores(peptide1, peptide2):
    scores = ''

    if len(peptide1) != len(peptide2):
        print "Peptides different lengths: Error"

    else:
        for i, cha in enumerate(peptide1):
            alignment_score = find_sim_score(cha, peptide2[i])
            if alignment_score >=0:
                str_score = '+' + str(alignment_score)
            else:
                str_score = str(alignment_score)
            scores = scores + str_score

    return scores

def get_peptides():
    # place holder until we start grabbing from database
    peptide_string = """
sQPPGEDsDtDVDDD
PLEKsQAsMVINsDt
    """
    raw_peptides = peptide_string.split('\n')
    peptides = [peptide[4:-4] for peptide in raw_peptides]
    del peptides[0] #get rid of blanks caused by extra \n's
    del peptides[-1]
    return peptides

def get_similarity_scores(peptides):
    sim_dict = {}
    for peptide in peptides:
        for inner_peptide in peptides:
            if peptide != inner_peptide:
                similarity = smith_waterman(peptide, inner_peptide)
                score_markers = get_score_markers(peptide, inner_peptide)
                sim_dict[peptide + '&&' + inner_peptide +'&&'+ score_markers] = similarity
    return sim_dict

def get_similarity_scores_simple(peptides):
    sim_dict = {}
    for peptide in peptides:
        for inner_peptide in peptides:
            if peptide != inner_peptide:
                similarity = calc_sim_score_simple(peptide, inner_peptide)
                score_markers = get_score_markers(peptide, inner_peptide)
                sim_dict[peptide + '&&' + inner_peptide +'&&'+ score_markers] = similarity
    return sim_dict

def calc_sim_score_simple(peptide1, peptide2):

    sum_score = 0
    
    for aa1, aa2 in zip(peptide1, peptide2):
        score = find_sim_score(aa1, aa2)
        #print score, sum_score
        sum_score = sum_score + score
        
    return sum_score

def get_similarity_scores_needle(peptides):
    sim_dict = {}
    for peptide in peptides:
        for inner_peptide in peptides:
            if peptide != inner_peptide:
                similarity = needle(peptide, inner_peptide)
                sim_dict[peptide + '&&' + inner_peptide] = similarity
    return sim_dict


def write_output(sim_dict):
    op = open('similarity_matrix.csv','w')
    op.write("Peptide1, Peptide2, sim score\n")

    for key,value in sim_dict.iteritems():
        peptides = key.split('&&')
        print peptides[0]
        print peptides[2]
        print peptides[1], value
        #for cha in peptides[0]:
        #    print cha,
        #print '\n'
        #print peptides[2]
        #for cha in peptides[1]:
        #    print cha,
        #print value , '\n'
        #print ''
        op.write(peptides[0] + ','+ peptides[1] + ',' + str(value) + '\n')
    op.close()

if __name__ == "__main__":
    #a = "ATAGACGACATACAGACAGCATACAGACAGCATACAGA"
    #b = "TTTAGCATGCGCATATCAGCAATACAGACAGATACG"

    #H = smith_waterman(a,b)
    #print "Similarity is ",H
    peptides = ["sQPPGEDsDtDVDDD","PLEKsQAsMVINsDt", "RRERGRPsLyVQRDI", "GLRRALssDsILsPA", "NVRVSNGsPsLErMD","EENVsDGsPNAGsVE"]
    sim_dict = get_similarity_scores_simple(peptides)
    write_output(sim_dict)
    
